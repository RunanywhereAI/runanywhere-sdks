/**
 * HybridRunAnywhere.hpp
 *
 * Nitrogen HybridObject implementation for RunAnywhere SDK.
 * This single C++ file works on both iOS and Android.
 *
 * The HybridRunAnywhereSpec base class is auto-generated by Nitrogen
 * from src/specs/RunAnywhere.nitro.ts
 */

#pragma once

// Include the generated spec header (created by nitrogen)
#if __has_include(<NitroModules/HybridObject.hpp>)
#include "HybridRunAnywhereSpec.hpp"
#else
// Fallback include path during development
#include "../nitrogen/generated/shared/c++/HybridRunAnywhereSpec.hpp"
#endif

// RunAnywhere Core C API
#if __has_include(<RunAnywhereCore/runanywhere_bridge.h>)
#include <RunAnywhereCore/runanywhere_bridge.h>
#elif __has_include("runanywhere_bridge.h")
#include "runanywhere_bridge.h"
#else
// Stub for compilation without the core library
typedef void* ra_backend_handle;
typedef int ra_result_code;
#define RA_SUCCESS 0
extern "C" {
  const char** ra_get_available_backends(int* count);
  ra_backend_handle ra_create_backend(const char* name);
  ra_result_code ra_initialize(ra_backend_handle, const char*);
  ra_result_code ra_destroy(ra_backend_handle);
  const char* ra_get_backend_info(ra_backend_handle);
  ra_result_code ra_load_model(ra_backend_handle, const char*, const char*);
  bool ra_is_model_loaded(ra_backend_handle);
  ra_result_code ra_unload_model(ra_backend_handle);
  ra_result_code ra_generate_text(ra_backend_handle, const char*, char*, size_t, int, float, void(*)(const char*, bool, void*), void*);
  void ra_cancel_generation(ra_backend_handle);
  ra_result_code ra_stt_load_model(ra_backend_handle, const char*, const char*, const char*);
  bool ra_stt_is_model_loaded(ra_backend_handle);
  ra_result_code ra_stt_unload_model(ra_backend_handle);
  ra_result_code ra_stt_transcribe(ra_backend_handle, const float*, size_t, int, const char*, char*, size_t);
  bool ra_stt_supports_streaming(ra_backend_handle);
  ra_result_code ra_tts_load_model(ra_backend_handle, const char*, const char*, const char*);
  bool ra_tts_is_model_loaded(ra_backend_handle);
  ra_result_code ra_tts_unload_model(ra_backend_handle);
  ra_result_code ra_tts_synthesize(ra_backend_handle, const char*, const char*, float, float, float**, size_t*, int*);
  void ra_free_audio(float*);
  ra_result_code ra_extract_archive(const char*, const char*);
  size_t ra_get_memory_usage(ra_backend_handle);
}
#endif

#include <mutex>
#include <string>

namespace margelo::nitro::runanywhere {

/**
 * HybridRunAnywhere - Main native implementation
 *
 * Implements the RunAnywhere interface defined in RunAnywhere.nitro.ts
 * All methods call runanywhere-core C API functions.
 */
class HybridRunAnywhere : public HybridRunAnywhereSpec {
public:
  HybridRunAnywhere();
  ~HybridRunAnywhere();

  // ============================================================================
  // Backend Lifecycle
  // ============================================================================

  std::shared_ptr<Promise<bool>> createBackend(const std::string& name) override;
  std::shared_ptr<Promise<bool>> initialize(const std::string& configJson) override;
  std::shared_ptr<Promise<void>> destroy() override;
  std::shared_ptr<Promise<bool>> isInitialized() override;
  std::shared_ptr<Promise<std::string>> getBackendInfo() override;

  // ============================================================================
  // Text Generation (LLM)
  // ============================================================================

  std::shared_ptr<Promise<bool>> loadTextModel(
    const std::string& path,
    const std::optional<std::string>& configJson) override;
  std::shared_ptr<Promise<bool>> isTextModelLoaded() override;
  std::shared_ptr<Promise<bool>> unloadTextModel() override;
  std::shared_ptr<Promise<std::string>> generate(
    const std::string& prompt,
    const std::optional<std::string>& optionsJson) override;
  std::shared_ptr<Promise<std::string>> generateStream(
    const std::string& prompt,
    const std::string& optionsJson,
    const std::function<void(const std::string&, bool)>& callback) override;
  std::shared_ptr<Promise<bool>> cancelGeneration() override;

  // ============================================================================
  // Speech-to-Text (STT)
  // ============================================================================

  std::shared_ptr<Promise<bool>> loadSTTModel(
    const std::string& path,
    const std::string& modelType,
    const std::optional<std::string>& configJson) override;
  std::shared_ptr<Promise<bool>> isSTTModelLoaded() override;
  std::shared_ptr<Promise<bool>> unloadSTTModel() override;
  std::shared_ptr<Promise<std::string>> transcribe(
    const std::string& audioBase64,
    double sampleRate,
    const std::optional<std::string>& language) override;
  std::shared_ptr<Promise<std::string>> transcribeFile(
    const std::string& filePath,
    const std::optional<std::string>& language) override;
  std::shared_ptr<Promise<bool>> supportsSTTStreaming() override;

  // ============================================================================
  // Text-to-Speech (TTS)
  // ============================================================================

  std::shared_ptr<Promise<bool>> loadTTSModel(
    const std::string& path,
    const std::string& modelType,
    const std::optional<std::string>& configJson) override;
  std::shared_ptr<Promise<bool>> isTTSModelLoaded() override;
  std::shared_ptr<Promise<bool>> unloadTTSModel() override;
  std::shared_ptr<Promise<std::string>> synthesize(
    const std::string& text,
    const std::string& voiceId,
    double speedRate,
    double pitchShift) override;
  std::shared_ptr<Promise<std::string>> getTTSVoices() override;

  // ============================================================================
  // Utility Functions
  // ============================================================================

  std::shared_ptr<Promise<std::string>> getLastError() override;
  std::shared_ptr<Promise<bool>> extractArchive(
    const std::string& archivePath,
    const std::string& destPath) override;
  std::shared_ptr<Promise<std::string>> getDeviceCapabilities() override;
  std::shared_ptr<Promise<double>> getMemoryUsage() override;

private:
  // Backend handles
  ra_backend_handle backend_ = nullptr;        // LlamaCpp backend
  ra_backend_handle onnxBackend_ = nullptr;    // ONNX backend for STT/TTS

  // Thread safety
  std::mutex backendMutex_;
  std::mutex modelMutex_;

  // State tracking
  bool isInitialized_ = false;
  std::string lastError_;

  // Helper methods
  std::string extractArchiveIfNeeded(const std::string& archivePath);
  void setLastError(const std::string& error);
};

} // namespace margelo::nitro::runanywhere

