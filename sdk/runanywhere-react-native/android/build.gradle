def getExtOrDefault(name) {
    return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.properties['RunAnywhere_' + name]
}

def reactNativeArchitectures() {
    def value = rootProject.getProperties().get("reactNativeArchitectures")
    return value ? value.split(",") : ["arm64-v8a"]
}

apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'
apply from: '../nitrogen/generated/android/runanywhere+autolinking.gradle'

apply plugin: 'com.facebook.react'

def getExtOrIntegerDefault(name) {
    if (rootProject.ext.has(name)) {
        return rootProject.ext.get(name)
    } else if (project.properties.containsKey('RunAnywhere_' + name)) {
        return (project.properties['RunAnywhere_' + name]).toInteger()
    }
    // Defaults for standalone builds
    def defaults = [
        'compileSdkVersion': 36,
        'minSdkVersion': 24,
        'targetSdkVersion': 36
    ]
    return defaults[name] ?: 36
}

// =============================================================================
// Native Library Configuration
// =============================================================================

// Version of pre-built native libraries to download
// First check SDK root native-version.txt, then android/ subdirectory, then fallback
def nativeLibVersion = project.findProperty("runanywhere.native.version") ?:
    (file("../native-version.txt").exists() ? file("../native-version.txt").text.trim() :
     file("native-version.txt").exists() ? file("native-version.txt").text.trim() : "0.0.1-dev.e6b7a2f")

// Use local build mode (requires runanywhere-core to be built locally)
def useLocalBuild = project.findProperty("runanywhere.testLocal")?.toBoolean() ?: false

// GitHub configuration for downloads
def githubOrg = project.findProperty("runanywhere.github.org") ?: "RunanywhereAI"
def githubRepo = project.findProperty("runanywhere.github.repo") ?: "runanywhere-binaries"

// Native libraries directory
def jniLibsDir = file("src/main/jniLibs")
def downloadedLibsDir = file("build/downloaded-libs")

// Local runanywhere-core path (for local builds)
def runAnywhereCoreDir = file("../../../../runanywhere-core")

android {
    namespace "com.margelo.nitro.runanywhere"

    compileSdkVersion getExtOrIntegerDefault('compileSdkVersion')

    defaultConfig {
        minSdkVersion getExtOrIntegerDefault('minSdkVersion')
        targetSdkVersion getExtOrIntegerDefault('targetSdkVersion')

        externalNativeBuild {
            cmake {
                cppFlags "-frtti -fexceptions -Wall -fstack-protector-all"
                arguments "-DANDROID_STL=c++_shared"
                abiFilters(*reactNativeArchitectures())
            }
        }
    }

    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }

    packagingOptions {
        excludes = [
            "META-INF",
            "META-INF/**"
        ]
        // React Native libraries that may conflict - prefer React Native's version
        pickFirsts = [
            "**/libc++_shared.so",
            "**/libjsi.so",
            "**/libfbjni.so",
            "**/libfolly_runtime.so"
        ]
        jniLibs {
            // Use legacy packaging to extract libraries to filesystem
            useLegacyPackaging = true
        }
    }

    buildFeatures {
        buildConfig true
        prefab true
    }

    buildTypes {
        release {
            minifyEnabled false
        }
    }

    lint {
        disable 'GradleCompatible'
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    sourceSets {
        main {
            java.srcDirs += [
                "generated/java",
                "generated/jni"
            ]

            // Configure jniLibs source based on build mode
            if (useLocalBuild) {
                // Local mode: use locally built libraries from runanywhere-core
                def unifiedDistDir = new File(runAnywhereCoreDir, "dist/android/unified")
                if (unifiedDistDir.exists()) {
                    jniLibs.srcDirs = [unifiedDistDir]
                    logger.lifecycle("Using local unified native libraries from: $unifiedDistDir")
                } else {
                    // Fallback: combine jni + llamacpp + onnx directories
                    def sourceDirs = []
                    def jniDir = new File(runAnywhereCoreDir, "dist/android/jni")
                    def llamacppDir = new File(runAnywhereCoreDir, "dist/android/llamacpp")
                    def onnxDir = new File(runAnywhereCoreDir, "dist/android/onnx")

                    if (jniDir.exists()) sourceDirs.add(jniDir)
                    if (llamacppDir.exists()) sourceDirs.add(llamacppDir)
                    if (onnxDir.exists()) sourceDirs.add(onnxDir)

                    if (!sourceDirs.isEmpty()) {
                        jniLibs.srcDirs = sourceDirs
                        logger.lifecycle("Using local native libraries from: ${sourceDirs.join(', ')}")
                    }
                }
            } else {
                jniLibs.srcDirs = [jniLibsDir]
            }
        }
    }
}

// =============================================================================
// Download Native Libraries Task
// =============================================================================

task downloadNativeLibs {
    description = "Downloads pre-built unified native library from GitHub releases"
    group = "build setup"

    def versionFile = file("${jniLibsDir}/.version")

    // Extract just the commit hash from version (e.g., "0.0.1-dev.2cd70fc" -> "2cd70fc")
    def shortVersion = nativeLibVersion.contains(".") ? nativeLibVersion.substring(nativeLibVersion.lastIndexOf(".") + 1) : nativeLibVersion

    // Unified archive with all backends in one package
    def unifiedArchive = "RunAnywhereUnified-android-${shortVersion}.zip"

    outputs.dir(jniLibsDir)
    outputs.upToDateWhen {
        versionFile.exists() && versionFile.text.trim() == nativeLibVersion
    }

    doLast {
        if (useLocalBuild) {
            logger.lifecycle("Skipping download - using local build mode")
            return
        }

        def currentVersion = versionFile.exists() ? versionFile.text.trim() : ""
        if (currentVersion == nativeLibVersion) {
            logger.lifecycle("Native libraries version $nativeLibVersion already downloaded")
            return
        }

        logger.lifecycle("Downloading unified native library version $nativeLibVersion...")

        // Create download directory
        downloadedLibsDir.mkdirs()

        // Clear existing jniLibs
        jniLibsDir.deleteDir()
        jniLibsDir.mkdirs()

        // Download unified archive
        def unifiedUrl = "https://github.com/$githubOrg/$githubRepo/releases/download/v$nativeLibVersion/$unifiedArchive"
        def unifiedZipFile = file("$downloadedLibsDir/$unifiedArchive")

        try {
            logger.lifecycle("Downloading unified archive: $unifiedArchive")
            logger.lifecycle("URL: $unifiedUrl")

            new URL(unifiedUrl).withInputStream { input ->
                unifiedZipFile.withOutputStream { output ->
                    output << input
                }
            }
            logger.lifecycle("Downloaded: ${unifiedZipFile.length() / 1024}KB")

            // Extract unified archive directly to jniLibs
            logger.lifecycle("Extracting unified archive...")
            copy {
                from zipTree(unifiedZipFile)
                into jniLibsDir
            }

            // List extracted files
            jniLibsDir.listFiles()?.findAll { it.isDirectory() }?.each { abiDir ->
                logger.lifecycle("  ${abiDir.name}/")
                abiDir.listFiles()?.findAll { it.name.endsWith(".so") }?.each { soFile ->
                    logger.lifecycle("    ${soFile.name} (${soFile.length() / 1024}KB)")
                }
            }

            logger.lifecycle("âœ… Unified native library installed successfully")
        } catch (Exception e) {
            logger.error("Failed to download unified native library: ${e.message}")
            logger.error("Download URL: $unifiedUrl")
            logger.error("")
            logger.error("Resolution options:")
            logger.error("  1. Check that version $nativeLibVersion exists in GitHub releases")
            logger.error("  2. Build locally: cd runanywhere-core && ./scripts/android/build.sh all")
            logger.error("  3. Use local mode: ./gradlew build -Prunanywhere.testLocal=true")
            throw new GradleException("Failed to download unified native library: $unifiedArchive", e)
        }

        // Write version marker
        versionFile.text = nativeLibVersion
        logger.lifecycle("Unified native library version $nativeLibVersion installed")
    }
}

// Make preBuild depend on download task when not using local build
if (!useLocalBuild) {
    preBuild.dependsOn downloadNativeLibs

    // Ensure codegen tasks also wait for native libs download
    afterEvaluate {
        tasks.matching {
            it.name.contains("generateCodegen") || it.name.contains("Codegen")
        }.configureEach {
            mustRunAfter downloadNativeLibs
        }
    }
}

// =============================================================================
// Clean Task
// =============================================================================

task cleanNativeLibs(type: Delete) {
    description = "Removes downloaded native libraries"
    group = "build"
    delete jniLibsDir
    delete downloadedLibsDir
}

clean.dependsOn cleanNativeLibs

repositories {
    mavenCentral()
    google()
}

dependencies {
    implementation "com.facebook.react:react-android"
    implementation project(":react-native-nitro-modules")

    // Apache Commons Compress for archive extraction on Android
    // (same library used by runanywhere-kotlin SDK)
    // Needed because Android pre-built binaries don't have libarchive linked
    implementation "org.apache.commons:commons-compress:1.26.0"
}
