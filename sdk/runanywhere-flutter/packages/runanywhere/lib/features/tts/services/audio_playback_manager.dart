import 'dart:async';
import 'dart:typed_data';
import 'package:runanywhere/foundation/logging/sdk_logger.dart';

/// Manages audio playback for TTS services
/// Matches iOS AudioPlaybackManager from Features/TTS/Services/AudioPlaybackManager.swift
///
/// This is a shared utility that works with any TTS backend.
/// It plays audio data generated by TTS synthesis.
///
/// Note: Flutter implementation uses platform channels or audio packages
/// for actual playback. This provides the interface matching iOS.
class AudioPlaybackManager {
  final SDKLogger _logger = SDKLogger(category: 'AudioPlayback');

  /// Whether audio is currently playing
  bool _isPlaying = false;

  /// Current playback time in seconds
  double _currentTime = 0.0;

  /// Total duration of current audio in seconds
  final double _duration = 0.0;

  /// Playback completion callback
  void Function(bool success)? _playbackCompletion;

  /// Completer for async playback
  Completer<void>? _playbackCompleter;

  /// Stream controller for playback state changes
  final _stateController = StreamController<AudioPlaybackState>.broadcast();

  /// Stream of playback state changes
  Stream<AudioPlaybackState> get stateStream => _stateController.stream;

  /// Whether audio is currently playing
  bool get isPlaying => _isPlaying;

  /// Current playback time in seconds
  double get currentTime => _currentTime;

  /// Total duration of current audio in seconds
  double get duration => _duration;

  AudioPlaybackManager() {
    _logger.info('AudioPlaybackManager initialized');
  }

  /// Play audio data asynchronously (async/await)
  /// [audioData] WAV or PCM audio data to play
  Future<void> play(Uint8List audioData) async {
    if (audioData.isEmpty) {
      throw AudioPlaybackError.emptyAudioData();
    }

    final completer = Completer<void>();
    _playbackCompleter = completer;

    try {
      await _startPlayback(audioData);
      await completer.future;
    } catch (e) {
      _playbackCompleter = null;
      rethrow;
    }
  }

  /// Play audio data with completion callback
  void playWithCompletion(
      Uint8List audioData, void Function(bool success) completion) {
    if (audioData.isEmpty) {
      _logger.warning('Empty audio data, skipping playback');
      completion(false);
      return;
    }

    _playbackCompletion = completion;

    try {
      unawaited(_startPlayback(audioData));
    } catch (e) {
      _logger.error('Failed to start playback: $e');
      _playbackCompletion = null;
      completion(false);
    }
  }

  /// Stop current playback
  void stop() {
    if (!_isPlaying) return;

    _cleanupPlayback(success: false);
    _logger.info('Playback stopped by user');
  }

  /// Pause current playback
  void pause() {
    if (!_isPlaying) return;

    // Platform-specific pause implementation would go here
    _logger.info('Playback paused');
  }

  /// Resume paused playback
  void resume() {
    // Platform-specific resume implementation would go here
    _logger.info('Playback resumed');
  }

  /// Start playback of audio data
  Future<void> _startPlayback(Uint8List audioData) async {
    // Stop any existing playback
    if (_isPlaying) {
      stop();
    }

    _isPlaying = true;
    _currentTime = 0.0;
    _stateController.add(AudioPlaybackState.playing);

    _logger.info('Playback started: ${audioData.length} bytes');

    // Note: Actual playback implementation would use platform-specific
    // audio APIs (e.g., just_audio, audioplayers packages)
    // This is the interface that matches iOS

    // Simulate playback completion for now
    // In real implementation, this would be triggered by platform callbacks
  }

  /// Clean up after playback
  void _cleanupPlayback({required bool success}) {
    _isPlaying = false;
    _currentTime = 0.0;
    _stateController.add(AudioPlaybackState.stopped);

    // Complete async playback if present
    final completer = _playbackCompleter;
    if (completer != null && !completer.isCompleted) {
      _playbackCompleter = null;
      if (success) {
        completer.complete();
      } else {
        completer.completeError(AudioPlaybackError.playbackInterrupted());
      }
    }

    // Call completion handler if present
    final completion = _playbackCompletion;
    if (completion != null) {
      _playbackCompletion = null;
      completion(success);
    }
  }

  /// Called when playback finishes naturally
  void onPlaybackComplete(bool success) {
    _logger.info('Playback finished: ${success ? "success" : "failed"}');
    _cleanupPlayback(success: success);
  }

  /// Called when a decode error occurs
  void onDecodeError(Object? error) {
    _logger.error('Playback decode error: ${error ?? "unknown"}');
    _cleanupPlayback(success: false);
  }

  /// Dispose resources
  void dispose() {
    stop();
    unawaited(_stateController.close());
  }
}

/// Audio playback state
enum AudioPlaybackState {
  stopped,
  playing,
  paused,
}

/// Audio playback errors
/// Matches iOS AudioPlaybackError
class AudioPlaybackError implements Exception {
  final String message;

  AudioPlaybackError(this.message);

  factory AudioPlaybackError.emptyAudioData() {
    return AudioPlaybackError('Audio data is empty');
  }

  factory AudioPlaybackError.playbackFailed() {
    return AudioPlaybackError('Failed to start audio playback');
  }

  factory AudioPlaybackError.playbackInterrupted() {
    return AudioPlaybackError('Audio playback was interrupted');
  }

  factory AudioPlaybackError.invalidAudioFormat() {
    return AudioPlaybackError('Invalid audio format');
  }

  @override
  String toString() => 'AudioPlaybackError: $message';
}
