// =============================================================================
// BINARY CONFIGURATION FOR RUNANYWHERE FLUTTER SDK - ANDROID
// =============================================================================
// This file controls whether to use local or remote native libraries (.so files).
// Similar to Swift Package.swift's testLocal flag.
//
// Set to `true` to use local binaries from android/src/main/jniLibs/
// Set to `false` to download binaries from GitHub releases (production mode)
// =============================================================================

ext {
    // Set this to true for local development/testing
    // Set to false for production builds (downloads from GitHub releases)
    testLocal = false

    // Remote binary configuration (used when testLocal = false)
    remoteVersion = "v0.0.1-dev.27bdcd0"
    remoteCommit = "27bdcd0"  // Short commit hash for artifact naming
    remoteBaseUrl = "https://github.com/RunanywhereAI/runanywhere-binaries/releases/download"

    // Android native libraries (unified package with ONNX + LlamaCPP)
    androidLibsUrl = "${remoteBaseUrl}/${remoteVersion}/RunAnywhereUnified-android-${remoteCommit}.zip"
    androidLibsChecksum = "7e09fe00bad585cc245fd98f89c34b58bc84904e26e118163210e564f4bf2c18"

    // Helper method to check if we should download
    shouldDownloadAndroidLibs = { ->
        return !testLocal
    }

    // Helper method to check if local libs exist
    checkLocalLibsExist = { ->
        def jniLibsDir = project.file('src/main/jniLibs')
        def arm64Dir = new File(jniLibsDir, 'arm64-v8a')

        if (!arm64Dir.exists() || !arm64Dir.isDirectory()) {
            return false
        }

        // Check for at least the bridge library
        def bridgeLib = new File(arm64Dir, 'librunanywhere_bridge.so')
        return bridgeLib.exists()
    }
}
