#!/bin/bash

# Build script for whisper-jni native library
# This script compiles whisper.cpp with JNI bindings for Android and JVM

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"
BUILD_DIR="$SCRIPT_DIR/build"
SRC_DIR="$SCRIPT_DIR/src"
WHISPER_DIR="$SCRIPT_DIR/whisper.cpp"
JNI_DIR="$SCRIPT_DIR/jni"
OUTPUT_DIR="$ROOT_DIR/src/jvmAndroidMain/resources/native"

echo -e "${GREEN}=== Building Whisper JNI Native Library ===${NC}"
echo "Script directory: $SCRIPT_DIR"
echo "Build directory: $BUILD_DIR"
echo "Output directory: $OUTPUT_DIR"

# Create directories
mkdir -p "$BUILD_DIR"
mkdir -p "$OUTPUT_DIR"
mkdir -p "$SRC_DIR"
mkdir -p "$JNI_DIR"

# Function to download whisper.cpp if needed
download_whisper() {
    if [ ! -d "$WHISPER_DIR" ]; then
        echo -e "${YELLOW}Downloading whisper.cpp...${NC}"
        git clone https://github.com/ggerganov/whisper.cpp.git "$WHISPER_DIR"
        cd "$WHISPER_DIR"
        # Use a stable commit
        git checkout v1.5.4
        cd "$SCRIPT_DIR"
    else
        echo -e "${GREEN}whisper.cpp already exists${NC}"
    fi
}

# Function to generate JNI headers
generate_jni_headers() {
    echo -e "${YELLOW}Generating JNI headers...${NC}"

    # Create the JNI header generation script
    cat > "$BUILD_DIR/generate-headers.sh" << 'EOF'
#!/bin/bash
cd "$(dirname "$0")"

# Compile the JNI wrapper class to get the header
javac -cp "../../../build/classes/kotlin/jvm/main" -d . ../../../src/jvmAndroidMain/kotlin/com/runanywhere/sdk/components/stt/WhisperJNI.kt

# Generate JNI header
javah -cp . -jni com.runanywhere.sdk.components.stt.WhisperJNI

# Move header to jni directory
mv com_runanywhere_sdk_components_stt_WhisperJNI.h ../jni/
EOF

    chmod +x "$BUILD_DIR/generate-headers.sh"

    # For now, create a basic header file manually since we need the Kotlin build to be working first
    cat > "$JNI_DIR/com_runanywhere_sdk_components_stt_WhisperJNI.h" << 'EOF'
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_runanywhere_sdk_components_stt_WhisperJNI */

#ifndef _Included_com_runanywhere_sdk_components_stt_WhisperJNI
#define _Included_com_runanywhere_sdk_components_stt_WhisperJNI
#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperInit
 * Signature: (Ljava/lang/String;)J
 */
JNIEXPORT jlong JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperInit
  (JNIEnv *, jclass, jstring);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperInitFromBuffer
 * Signature: ([B)J
 */
JNIEXPORT jlong JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperInitFromBuffer
  (JNIEnv *, jclass, jbyteArray);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperFree
 * Signature: (J)V
 */
JNIEXPORT void JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperFree
  (JNIEnv *, jclass, jlong);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperGetModelInfo
 * Signature: (J)Lcom/runanywhere/sdk/components/stt/WhisperModelInfo;
 */
JNIEXPORT jobject JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperGetModelInfo
  (JNIEnv *, jclass, jlong);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperTranscribe
 * Signature: (J[FLjava/lang/String;ZZ)Lcom/runanywhere/sdk/components/stt/WhisperResult;
 */
JNIEXPORT jobject JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperTranscribe
  (JNIEnv *, jclass, jlong, jfloatArray, jstring, jboolean, jboolean);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperTranscribeWithParams
 * Signature: (J[FLcom/runanywhere/sdk/components/stt/WhisperParams;)Lcom/runanywhere/sdk/components/stt/WhisperResult;
 */
JNIEXPORT jobject JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperTranscribeWithParams
  (JNIEnv *, jclass, jlong, jfloatArray, jobject);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperGetLanguageCount
 * Signature: (J)I
 */
JNIEXPORT jint JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperGetLanguageCount
  (JNIEnv *, jclass, jlong);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    whisperGetLanguageProbs
 * Signature: (J)[Lcom/runanywhere/sdk/components/stt/WhisperLanguageProb;
 */
JNIEXPORT jobjectArray JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperGetLanguageProbs
  (JNIEnv *, jclass, jlong);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    convertPcmToFloat
 * Signature: ([BII)[F
 */
JNIEXPORT jfloatArray JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_convertPcmToFloat
  (JNIEnv *, jclass, jbyteArray, jint, jint);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    getVersion
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_getVersion
  (JNIEnv *, jclass);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    isGpuAvailable
 * Signature: ()Z
 */
JNIEXPORT jboolean JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_isGpuAvailable
  (JNIEnv *, jclass);

/*
 * Class:     com_runanywhere_sdk_components_stt_WhisperJNI
 * Method:    setGpuAcceleration
 * Signature: (Z)Z
 */
JNIEXPORT jboolean JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_setGpuAcceleration
  (JNIEnv *, jclass, jboolean);

#ifdef __cplusplus
}
#endif
#endif
EOF
}

# Function to create JNI implementation
create_jni_implementation() {
    echo -e "${YELLOW}Creating JNI implementation...${NC}"

    cat > "$SRC_DIR/whisper_jni.cpp" << 'EOF'
#include <jni.h>
#include <string>
#include <vector>
#include <memory>
#include <android/log.h>
#include "../jni/com_runanywhere_sdk_components_stt_WhisperJNI.h"
#include "../whisper.cpp/whisper.h"

#define LOG_TAG "WhisperJNI"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

// Helper functions
std::string jstring_to_string(JNIEnv* env, jstring jstr) {
    if (jstr == nullptr) return "";
    const char* chars = env->GetStringUTFChars(jstr, nullptr);
    std::string result(chars);
    env->ReleaseStringUTFChars(jstr, chars);
    return result;
}

jstring string_to_jstring(JNIEnv* env, const std::string& str) {
    return env->NewStringUTF(str.c_str());
}

// JNI implementations
JNIEXPORT jlong JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperInit
  (JNIEnv* env, jclass clazz, jstring model_path) {

    std::string path = jstring_to_string(env, model_path);
    LOGI("Initializing whisper with model: %s", path.c_str());

    struct whisper_context* ctx = whisper_init_from_file(path.c_str());
    if (ctx == nullptr) {
        LOGE("Failed to initialize whisper context from file: %s", path.c_str());
        return 0;
    }

    LOGI("Whisper context initialized successfully");
    return reinterpret_cast<jlong>(ctx);
}

JNIEXPORT jlong JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperInitFromBuffer
  (JNIEnv* env, jclass clazz, jbyteArray model_data) {

    jsize data_len = env->GetArrayLength(model_data);
    jbyte* data_ptr = env->GetByteArrayElements(model_data, nullptr);

    LOGI("Initializing whisper from buffer (%d bytes)", data_len);

    struct whisper_context* ctx = whisper_init_from_buffer(data_ptr, data_len);

    env->ReleaseByteArrayElements(model_data, data_ptr, JNI_ABORT);

    if (ctx == nullptr) {
        LOGE("Failed to initialize whisper context from buffer");
        return 0;
    }

    LOGI("Whisper context initialized from buffer successfully");
    return reinterpret_cast<jlong>(ctx);
}

JNIEXPORT void JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperFree
  (JNIEnv* env, jclass clazz, jlong context_handle) {

    if (context_handle == 0) return;

    struct whisper_context* ctx = reinterpret_cast<struct whisper_context*>(context_handle);
    whisper_free(ctx);

    LOGI("Whisper context freed");
}

JNIEXPORT jobject JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperGetModelInfo
  (JNIEnv* env, jclass clazz, jlong context_handle) {

    if (context_handle == 0) return nullptr;

    struct whisper_context* ctx = reinterpret_cast<struct whisper_context*>(context_handle);

    // Get model information
    int n_vocab = whisper_n_vocab(ctx);
    int n_audio_ctx = whisper_n_audio_ctx(ctx);
    int n_audio_state = whisper_n_audio_state(ctx);
    int n_audio_head = whisper_n_audio_head(ctx);
    int n_audio_layer = whisper_n_audio_layer(ctx);
    int n_text_ctx = whisper_n_text_ctx(ctx);
    int n_text_state = whisper_n_text_state(ctx);
    int n_text_head = whisper_n_text_head(ctx);
    int n_text_layer = whisper_n_text_layer(ctx);
    int n_mels = whisper_n_mels(ctx);
    bool is_multilingual = whisper_is_multilingual(ctx);

    // Create WhisperModelInfo object
    jclass model_info_class = env->FindClass("com/runanywhere/sdk/components/stt/WhisperModelInfo");
    jmethodID constructor = env->GetMethodID(model_info_class, "<init>",
        "(Ljava/lang/String;Ljava/lang/String;IIIIIIIIIIZ)V");

    return env->NewObject(model_info_class, constructor,
        string_to_jstring(env, "whisper"),  // name
        string_to_jstring(env, "base"),     // type
        n_vocab,         // vocab
        n_mels,          // nMels
        n_audio_ctx,     // nAudioCtx
        n_audio_state,   // nAudioState
        n_audio_head,    // nAudioHead
        n_audio_layer,   // nAudioLayer
        n_text_ctx,      // nTextCtx
        n_text_state,    // nTextState
        n_text_head,     // nTextHead
        n_text_layer,    // nTextLayer
        is_multilingual  // isMultilingual
    );
}

JNIEXPORT jobject JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperTranscribe
  (JNIEnv* env, jclass clazz, jlong context_handle, jfloatArray audio_data,
   jstring language, jboolean enable_timestamps, jboolean enable_translate) {

    if (context_handle == 0) return nullptr;

    struct whisper_context* ctx = reinterpret_cast<struct whisper_context*>(context_handle);

    // Get audio data
    jsize audio_len = env->GetArrayLength(audio_data);
    jfloat* audio_ptr = env->GetFloatArrayElements(audio_data, nullptr);

    // Set up whisper parameters
    struct whisper_full_params params = whisper_full_default_params(WHISPER_SAMPLING_GREEDY);

    std::string lang = jstring_to_string(env, language);
    if (!lang.empty()) {
        const int lang_id = whisper_lang_id(lang.c_str());
        if (lang_id >= 0) {
            params.language = lang.c_str();
        }
    }

    params.translate = enable_translate;
    params.print_timestamps = enable_timestamps;
    params.no_timestamps = !enable_timestamps;

    LOGD("Starting transcription with %d samples", audio_len);

    // Run transcription
    int result = whisper_full(ctx, params, audio_ptr, audio_len);

    env->ReleaseFloatArrayElements(audio_data, audio_ptr, JNI_ABORT);

    if (result != 0) {
        LOGE("Whisper transcription failed with code: %d", result);
        return nullptr;
    }

    // Get results
    const int n_segments = whisper_full_n_segments(ctx);
    std::string full_text;

    // Create segments array
    jclass segment_class = env->FindClass("com/runanywhere/sdk/components/stt/WhisperSegment");
    jmethodID segment_constructor = env->GetMethodID(segment_class, "<init>",
        "(Ljava/lang/String;DDFLjava/util/List;)V");

    jobjectArray segments_array = env->NewObjectArray(n_segments, segment_class, nullptr);

    for (int i = 0; i < n_segments; ++i) {
        const char* text = whisper_full_get_segment_text(ctx, i);
        const int64_t t0 = whisper_full_get_segment_t0(ctx, i);
        const int64_t t1 = whisper_full_get_segment_t1(ctx, i);

        double start_time = t0 * 0.01; // Convert to seconds
        double end_time = t1 * 0.01;

        full_text += text;

        // Create empty token list for now
        jclass list_class = env->FindClass("java/util/ArrayList");
        jmethodID list_constructor = env->GetMethodID(list_class, "<init>", "()V");
        jobject token_list = env->NewObject(list_class, list_constructor);

        jobject segment = env->NewObject(segment_class, segment_constructor,
            string_to_jstring(env, text),
            start_time,
            end_time,
            1.0f, // confidence
            token_list
        );

        env->SetObjectArrayElement(segments_array, i, segment);
    }

    // Create result object
    jclass result_class = env->FindClass("com/runanywhere/sdk/components/stt/WhisperResult");
    jmethodID result_constructor = env->GetMethodID(result_class, "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Ljava/util/List;Ljava/util/Map;J)V");

    // Convert segments array to list
    jclass arrays_class = env->FindClass("java/util/Arrays");
    jmethodID as_list_method = env->GetStaticMethodID(arrays_class, "asList",
        "([Ljava/lang/Object;)Ljava/util/List;");
    jobject segments_list = env->CallStaticObjectMethod(arrays_class, as_list_method, segments_array);

    // Create empty language probs map
    jclass map_class = env->FindClass("java/util/HashMap");
    jmethodID map_constructor = env->GetMethodID(map_class, "<init>", "()V");
    jobject lang_probs_map = env->NewObject(map_class, map_constructor);

    LOGI("Transcription completed: %s", full_text.substr(0, 50).c_str());

    return env->NewObject(result_class, result_constructor,
        string_to_jstring(env, full_text),
        string_to_jstring(env, lang.empty() ? "en" : lang),
        segments_list,
        lang_probs_map,
        0L // processing time
    );
}

// Stub implementations for other methods
JNIEXPORT jobject JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperTranscribeWithParams
  (JNIEnv* env, jclass clazz, jlong context_handle, jfloatArray audio_data, jobject params) {
    // For now, delegate to basic transcribe with default parameters
    return Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperTranscribe(
        env, clazz, context_handle, audio_data, nullptr, JNI_FALSE, JNI_FALSE);
}

JNIEXPORT jint JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperGetLanguageCount
  (JNIEnv* env, jclass clazz, jlong context_handle) {
    return whisper_lang_max_id() + 1;
}

JNIEXPORT jobjectArray JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_whisperGetLanguageProbs
  (JNIEnv* env, jclass clazz, jlong context_handle) {
    // Return empty array for now
    jclass prob_class = env->FindClass("com/runanywhere/sdk/components/stt/WhisperLanguageProb");
    return env->NewObjectArray(0, prob_class, nullptr);
}

JNIEXPORT jfloatArray JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_convertPcmToFloat
  (JNIEnv* env, jclass clazz, jbyteArray pcm_data, jint sample_rate, jint target_rate) {

    jsize data_len = env->GetArrayLength(pcm_data);
    jbyte* data_ptr = env->GetByteArrayElements(pcm_data, nullptr);

    // Convert 16-bit PCM to float
    int sample_count = data_len / 2; // 16-bit = 2 bytes per sample
    jfloatArray result = env->NewFloatArray(sample_count);
    jfloat* result_ptr = env->GetFloatArrayElements(result, nullptr);

    const int16_t* samples = reinterpret_cast<const int16_t*>(data_ptr);

    for (int i = 0; i < sample_count; ++i) {
        result_ptr[i] = static_cast<float>(samples[i]) / 32768.0f;
    }

    env->ReleaseByteArrayElements(pcm_data, data_ptr, JNI_ABORT);
    env->ReleaseFloatArrayElements(result, result_ptr, 0);

    return result;
}

JNIEXPORT jstring JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_getVersion
  (JNIEnv* env, jclass clazz) {
    return string_to_jstring(env, "whisper.cpp-v1.5.4");
}

JNIEXPORT jboolean JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_isGpuAvailable
  (JNIEnv* env, jclass clazz) {
    return JNI_FALSE; // GPU acceleration not implemented yet
}

JNIEXPORT jboolean JNICALL Java_com_runanywhere_sdk_components_stt_WhisperJNI_setGpuAcceleration
  (JNIEnv* env, jclass clazz, jboolean enable) {
    return JNI_FALSE; // GPU acceleration not implemented yet
}
EOF
}

# Function to create CMake build file
create_cmake_build() {
    echo -e "${YELLOW}Creating CMake build configuration...${NC}"

    cat > "$SCRIPT_DIR/CMakeLists.txt" << 'EOF'
cmake_minimum_required(VERSION 3.18)
project(whisper-jni)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find JNI
find_package(JNI REQUIRED)

# Add whisper.cpp
add_subdirectory(whisper.cpp)

# Add our JNI wrapper
add_library(whisper-jni SHARED
    src/whisper_jni.cpp
)

# Include directories
target_include_directories(whisper-jni PRIVATE
    ${JNI_INCLUDE_DIRS}
    whisper.cpp
    jni
)

# Link libraries
target_link_libraries(whisper-jni
    whisper
    ${JNI_LIBRARIES}
)

# Android specific settings
if(ANDROID)
    target_link_libraries(whisper-jni
        android
        log
    )
endif()

# Compiler flags
target_compile_options(whisper-jni PRIVATE
    -O3
    -fPIC
)

if(ANDROID)
    target_compile_definitions(whisper-jni PRIVATE
        ANDROID=1
    )
endif()

# Set output directory
set_target_properties(whisper-jni PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../src/jvmAndroidMain/resources/native
)
EOF
}

# Function to build for Android (requires Android NDK)
build_android() {
    echo -e "${YELLOW}Building for Android...${NC}"

    if [ -z "$ANDROID_NDK_HOME" ] && [ -z "$ANDROID_NDK_ROOT" ]; then
        echo -e "${RED}Android NDK not found. Please set ANDROID_NDK_HOME or ANDROID_NDK_ROOT${NC}"
        return 1
    fi

    NDK_PATH="${ANDROID_NDK_HOME:-$ANDROID_NDK_ROOT}"

    # Build for ARM64
    mkdir -p "$BUILD_DIR/android-arm64"
    cd "$BUILD_DIR/android-arm64"

    cmake -DCMAKE_TOOLCHAIN_FILE="$NDK_PATH/build/cmake/android.toolchain.cmake" \
          -DANDROID_ABI=arm64-v8a \
          -DANDROID_PLATFORM=android-24 \
          -DCMAKE_BUILD_TYPE=Release \
          "$SCRIPT_DIR"

    make -j$(nproc)

    # Copy to output
    mkdir -p "$OUTPUT_DIR/android/arm64-v8a"
    cp libwhisper-jni.so "$OUTPUT_DIR/android/arm64-v8a/"

    cd "$SCRIPT_DIR"
    echo -e "${GREEN}Android ARM64 build completed${NC}"
}

# Function to build for JVM (Linux/macOS)
build_jvm() {
    echo -e "${YELLOW}Building for JVM...${NC}"

    mkdir -p "$BUILD_DIR/jvm"
    cd "$BUILD_DIR/jvm"

    cmake -DCMAKE_BUILD_TYPE=Release "$SCRIPT_DIR"
    make -j$(nproc)

    # Copy to output with platform-specific name
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        mkdir -p "$OUTPUT_DIR/linux"
        cp libwhisper-jni.so "$OUTPUT_DIR/linux/"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        mkdir -p "$OUTPUT_DIR/macos"
        cp libwhisper-jni.dylib "$OUTPUT_DIR/macos/"
    fi

    cd "$SCRIPT_DIR"
    echo -e "${GREEN}JVM build completed${NC}"
}

# Function to create documentation
create_docs() {
    echo -e "${YELLOW}Creating documentation...${NC}"

    cat > "$SCRIPT_DIR/README.md" << 'EOF'
# Whisper JNI Native Library

This directory contains the native library implementation for whisper.cpp JNI bindings used by the RunAnywhere KMP SDK.

## Structure

```
native/whisper-jni/
├── build-native.sh          # Build script
├── CMakeLists.txt           # CMake configuration
├── README.md               # This file
├── whisper.cpp/            # Whisper.cpp submodule (auto-downloaded)
├── jni/                    # JNI headers
├── src/                    # C++ implementation
│   └── whisper_jni.cpp     # Main JNI wrapper
└── build/                  # Build directory (generated)
```

## Building

### Prerequisites

- CMake 3.18+
- C++17 compiler (GCC, Clang, or MSVC)
- Android NDK (for Android builds)
- JDK with JNI headers

### Build Commands

```bash
# Build for current platform (JVM)
./build-native.sh jvm

# Build for Android (requires Android NDK)
./build-native.sh android

# Build all platforms
./build-native.sh all

# Clean build
./build-native.sh clean
```

### Environment Variables

- `ANDROID_NDK_HOME` or `ANDROID_NDK_ROOT`: Path to Android NDK
- `JAVA_HOME`: Path to JDK (for JNI headers)

## Output

Built libraries are placed in:
- `../src/jvmAndroidMain/resources/native/`
  - `android/arm64-v8a/libwhisper-jni.so`
  - `linux/libwhisper-jni.so`
  - `macos/libwhisper-jni.dylib`
  - `windows/whisper-jni.dll`

## Usage

The native library is automatically loaded by the `WhisperJNI` Kotlin object when the SDK is used.

## Performance Notes

- Optimized for speech recognition at 16kHz sample rate
- Uses CPU-based inference (GPU support planned)
- Memory usage scales with model size (base: ~140MB, small: ~244MB, etc.)
- Real-time factor typically 0.1-0.3x (faster than real-time)

## Troubleshooting

### Library Loading Issues

1. Check that the correct architecture library is built
2. Verify JNI method signatures match
3. Ensure native library is in the correct resource path

### Runtime Errors

1. Check whisper model file exists and is readable
2. Verify audio format (16kHz, mono, float32 or int16)
3. Check memory availability (models require significant RAM)

### Build Issues

1. Ensure CMake and compilers are up to date
2. For Android: verify NDK path and version (r21+ recommended)
3. For JVM: check JAVA_HOME points to JDK (not JRE)
EOF
}

# Main execution
main() {
    case "${1:-all}" in
        "download")
            download_whisper
            ;;
        "headers")
            generate_jni_headers
            ;;
        "impl")
            create_jni_implementation
            ;;
        "cmake")
            create_cmake_build
            ;;
        "android")
            download_whisper
            generate_jni_headers
            create_jni_implementation
            create_cmake_build
            build_android
            ;;
        "jvm")
            download_whisper
            generate_jni_headers
            create_jni_implementation
            create_cmake_build
            build_jvm
            ;;
        "all")
            download_whisper
            generate_jni_headers
            create_jni_implementation
            create_cmake_build
            create_docs
            echo -e "${GREEN}All setup completed. To build:${NC}"
            echo "  For Android: $0 android"
            echo "  For JVM: $0 jvm"
            ;;
        "clean")
            rm -rf "$BUILD_DIR"
            rm -rf "$OUTPUT_DIR"
            echo -e "${GREEN}Build directories cleaned${NC}"
            ;;
        *)
            echo "Usage: $0 [download|headers|impl|cmake|android|jvm|all|clean]"
            echo ""
            echo "Commands:"
            echo "  download - Download whisper.cpp"
            echo "  headers  - Generate JNI headers"
            echo "  impl     - Create JNI implementation"
            echo "  cmake    - Create CMake build files"
            echo "  android  - Build for Android"
            echo "  jvm      - Build for JVM"
            echo "  all      - Setup all files (default)"
            echo "  clean    - Clean build directories"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
