---
phase: 02-ios-app-rag-feature
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/ios/RunAnywhereAI/RunAnywhereAI/Features/RAG/Services/DocumentService.swift
  - examples/ios/RunAnywhereAI/RunAnywhereAI/Features/RAG/ViewModels/RAGViewModel.swift
autonomous: true
requirements: [APP-01, APP-02, APP-03, APP-04]

must_haves:
  truths:
    - "DocumentService can extract plain text from a PDF file URL using PDFKit"
    - "DocumentService can extract plain text from a JSON file URL"
    - "RAGViewModel can orchestrate the full document load flow: pick -> extract -> ingest"
    - "RAGViewModel can send a question to the SDK and receive an answer"
    - "RAGViewModel preserves loaded document state across multiple queries"
  artifacts:
    - path: "examples/ios/RunAnywhereAI/RunAnywhereAI/Features/RAG/Services/DocumentService.swift"
      provides: "PDF and JSON text extraction"
      contains: "PDFDocument"
    - path: "examples/ios/RunAnywhereAI/RunAnywhereAI/Features/RAG/ViewModels/RAGViewModel.swift"
      provides: "RAG orchestration ViewModel with document state and query methods"
      contains: "ragQuery"
  key_links:
    - from: "RAGViewModel.swift"
      to: "RunAnywhere.ragIngest"
      via: "SDK public API call"
      pattern: "RunAnywhere\\.ragIngest"
    - from: "RAGViewModel.swift"
      to: "RunAnywhere.ragQuery"
      via: "SDK public API call"
      pattern: "RunAnywhere\\.ragQuery"
    - from: "RAGViewModel.swift"
      to: "DocumentService.swift"
      via: "Text extraction before ingestion"
      pattern: "DocumentService\\.extractText"
---

<objective>
Create the data/logic layer for the iOS app RAG feature: a DocumentService for PDF/JSON text extraction and a RAGViewModel that orchestrates the full document-load-and-query lifecycle using the SDK RAG APIs built in Phase 1.

Purpose: Separate business logic (extraction, SDK calls, state) from presentation so the UI plan can focus purely on views.
Output: DocumentService.swift, RAGViewModel.swift — ready for the UI layer to bind to.
</objective>

<execution_context>
@/Users/guruvyas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guruvyas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-swift-sdk-rag-component/01-02-SUMMARY.md

# SDK RAG public API (what this plan calls)
@sdk/runanywhere-swift/Sources/RunAnywhere/Public/Extensions/RAG/RunAnywhere+RAG.swift
@sdk/runanywhere-swift/Sources/RunAnywhere/Public/Extensions/RAG/RAGTypes.swift

# Existing app patterns to follow
@examples/ios/RunAnywhereAI/RunAnywhereAI/Features/Chat/ViewModels/LLMViewModel.swift
@examples/ios/RunAnywhereAI/RunAnywhereAI/Core/Models/AppTypes.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DocumentService for PDF and JSON text extraction</name>
  <files>examples/ios/RunAnywhereAI/RunAnywhereAI/Features/RAG/Services/DocumentService.swift</files>
  <action>
Create `DocumentService.swift` in `Features/RAG/Services/`.

This is a simple utility struct (no state, no singleton needed) with one public static method:

```swift
import PDFKit
import Foundation

enum DocumentType {
    case pdf
    case json
    case unsupported

    init(url: URL) {
        switch url.pathExtension.lowercased() {
        case "pdf": self = .pdf
        case "json": self = .json
        default: self = .unsupported
        }
    }
}

enum DocumentServiceError: LocalizedError {
    case unsupportedFormat(String)
    case pdfExtractionFailed
    case jsonExtractionFailed(String)
    case fileReadFailed(String)

    var errorDescription: String? { /* descriptive messages */ }
}

struct DocumentService {
    static func extractText(from url: URL) throws -> String
}
```

**PDF extraction:** Use `PDFKit.PDFDocument(url:)` — iterate all pages via `page(at:)`, call `string` on each page, join with newlines. PDFKit is a system framework (no pod needed), available iOS 11+. If `PDFDocument` init returns nil or page text is empty, throw `pdfExtractionFailed`.

**JSON extraction:** Read data with `Data(contentsOf: url)`, deserialize with `JSONSerialization`, then recursively extract all string values from the parsed object (handle dictionaries and arrays). Join all extracted strings with newlines. This gives a flat text representation suitable for RAG ingestion. If deserialization fails, throw `jsonExtractionFailed` with the underlying error message.

**Unsupported:** Throw `unsupportedFormat` with the file extension.

The method should call `url.startAccessingSecurityScopedResource()` at the start and `url.stopAccessingSecurityScopedResource()` in a defer block — this is required for files picked via UIDocumentPickerViewController (security-scoped URLs).

Keep it simple: no async needed since PDFKit and file reads are synchronous and fast for typical documents.
  </action>
  <verify>
Build the iOS project: `cd examples/ios/RunAnywhereAI && xcodebuild build -scheme RunAnywhereAI -destination 'platform=iOS Simulator,name=iPhone 16 Pro' -quiet 2>&1 | tail -5`. The build must succeed with no errors referencing DocumentService.
  </verify>
  <done>DocumentService.extractText(from:) compiles, handles .pdf via PDFKit and .json via JSONSerialization, throws typed errors for unsupported formats and extraction failures.</done>
</task>

<task type="auto">
  <name>Task 2: Create RAGViewModel for document lifecycle and query orchestration</name>
  <files>examples/ios/RunAnywhereAI/RunAnywhereAI/Features/RAG/ViewModels/RAGViewModel.swift</files>
  <action>
Create `RAGViewModel.swift` in `Features/RAG/ViewModels/`.

Follow the `LLMViewModel` pattern: `@MainActor @Observable final class RAGViewModel`.

**State properties** (all `private(set)` for external read-only):

```swift
// Document state
private(set) var documentName: String?          // Name of loaded document (nil = none loaded)
private(set) var isDocumentLoaded = false        // True after successful ingestion
private(set) var isLoadingDocument = false        // True during extraction + ingestion

// Query state
private(set) var messages: [(role: MessageRole, text: String)] = []  // Conversation history
private(set) var isQuerying = false              // True while RAG query is in-flight
private(set) var error: Error?                   // Latest error (cleared on new action)

// Input
var currentQuestion = ""
```

Define a simple `MessageRole` enum: `.user`, `.assistant`, `.system`.

Use `import os.log` for a Logger instance: `Logger(subsystem: "com.runanywhere.RunAnywhereAI", category: "RAGViewModel")`.

**Methods:**

1. `func loadDocument(url: URL) async` — The main flow:
   - Set `isLoadingDocument = true`, clear `error`
   - Determine `DocumentType` from URL
   - Call `DocumentService.extractText(from: url)` (synchronous, run on MainActor is fine for typical docs)
   - Call `try await RunAnywhere.ragCreatePipeline(config:)` with a default `RAGConfiguration` — use hardcoded model paths for now (the example app manages models separately; use placeholder paths that the app's model manager would provide). Actually: accept an optional `RAGConfiguration` parameter or store a configuration. For MVP, make the pipeline config a stored property `var pipelineConfig: RAGConfiguration?` that the view can set before calling loadDocument, or pass it as a parameter.
   - **Simpler approach**: Add a `func loadDocument(url: URL, config: RAGConfiguration) async` signature. The view will construct the config with model paths from the app's model selection.
   - Call `try await RunAnywhere.ragIngest(text: extractedText)`
   - Set `documentName = url.lastPathComponent`, `isDocumentLoaded = true`
   - On error: set `self.error`, log it
   - Always: set `isLoadingDocument = false` in defer

2. `func askQuestion() async` — Query flow:
   - Guard `!currentQuestion.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty`
   - Guard `isDocumentLoaded`
   - Append user message to `messages`
   - Set `isQuerying = true`, clear `error`
   - Call `try await RunAnywhere.ragQuery(question: currentQuestion)`
   - Append assistant message with `result.answer`
   - Clear `currentQuestion`
   - On error: set `self.error`, append error message to messages
   - Always: set `isQuerying = false`

3. `func clearDocument() async` — Reset flow:
   - Call `await RunAnywhere.ragDestroyPipeline()`
   - Reset all state: `documentName = nil`, `isDocumentLoaded = false`, `messages = []`, `error = nil`

**Important:** Do NOT import or depend on SwiftUI except through `@Observable` (which is in the Observation framework). The ViewModel should only import `Foundation`, `RunAnywhere`, `os.log`, and `Observation`.

Do NOT use NSLock (per project rules). No concurrency primitives needed since everything is @MainActor.
  </action>
  <verify>
Build the iOS project: `cd examples/ios/RunAnywhereAI && xcodebuild build -scheme RunAnywhereAI -destination 'platform=iOS Simulator,name=iPhone 16 Pro' -quiet 2>&1 | tail -5`. Build succeeds. Grep for `RunAnywhere.ragIngest` and `RunAnywhere.ragQuery` in RAGViewModel.swift to confirm SDK wiring.
  </verify>
  <done>RAGViewModel compiles with loadDocument/askQuestion/clearDocument methods that call the SDK RAG APIs. Document state persists across multiple askQuestion calls (APP-04). Error handling surfaces errors via the error property.</done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds for the iOS example app with both new files
2. `DocumentService.extractText(from:)` handles PDF (via PDFKit) and JSON (via JSONSerialization)
3. `RAGViewModel` calls `RunAnywhere.ragIngest` for document loading and `RunAnywhere.ragQuery` for questions
4. `RAGViewModel.isDocumentLoaded` remains true across multiple `askQuestion` calls (persistent session)
5. No NSLock usage, no mock implementations
</verification>

<success_criteria>
- DocumentService compiles and handles PDF + JSON extraction with typed errors
- RAGViewModel compiles and orchestrates the full RAG lifecycle via SDK APIs
- Document state persists for follow-up queries (APP-04)
- Both files follow established app patterns (@MainActor @Observable for VM, struct for service)
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-ios-app-rag-feature/02-01-SUMMARY.md`
</output>
